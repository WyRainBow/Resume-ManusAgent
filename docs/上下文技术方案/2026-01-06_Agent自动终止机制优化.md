# Agent 自动终止机制优化

**日期**: 2026-01-06
**类型**: 性能优化、架构改进
**影响范围**: `app/agent/toolcall.py`, `app/agent/manus.py`

---

## 📋 问题分析

### 问题发现过程

在测试过程中，用户反馈了一个严重的问题：**Agent 在回答简单问题时卡住，显示"AI 正在思考中"但永远不会返回结果**。

通过浏览器工具测试和日志分析，我们发现了以下问题：

### 核心问题 1：无限循环 - Agent 无法自动终止

**问题现象**：
- 用户问"我是哪个大学的"时，Agent 会正确回答"中山大学"
- 但回答后，Agent 不会终止，继续执行下一步
- 导致前端一直显示"AI 正在思考中"，实际上 Agent 在重复执行相同的逻辑

**根本原因**：
```python
# 优化前的 think() 方法
if self.tool_choices == ToolChoice.AUTO and not self.tool_calls:
    return bool(content)  # ❌ 问题：返回 True 导致继续执行
```

当 LLM 返回纯文本回答（无 tool_calls）时：
- `think()` 返回 `True`（因为有 content）
- Agent 继续执行 `step()` 循环
- 下一次 `think()` 又返回相同的内容
- 形成无限循环

**测试数据（优化前）**：
| 场景 | 步数 | 消息数 | 问题 |
|------|------|--------|------|
| 问"我是哪个大学的" | 10步 | 27条 | ❌ 无限循环 |
| 问"介绍一下广东工业大学" | 10步 | 48条 | ❌ 无限循环 |
| 总消息数 | - | 48条 | ❌ 消息膨胀 |

### 核心问题 2：流处理中状态检查缺失

**问题现象**：
- 即使 `think()` 设置了 `self.state = AgentState.FINISHED`
- 流处理循环 `agent_stream.py` 中的 `while` 循环没有立即检查状态
- 导致循环继续执行，直到达到 `max_steps`

**根本原因**：
```python
# 优化前的 agent_stream.py
while self.agent.current_step < max_steps and self.agent.state != SchemaAgentState.FINISHED:
    step_result = await self.agent.step()
    # ❌ 问题：没有在 step() 后立即检查状态
    # 即使 step() 内部设置了 FINISHED，循环也会继续
    new_messages = self.agent.memory.messages[msg_count_before:]
    # ... 处理消息
```

**问题流程**：
1. `agent.step()` → `think()` 设置 `state = FINISHED` 并返回 `False`
2. `step()` 返回 "Thinking complete - no action needed"
3. 但循环继续，因为状态检查在循环开始时就完成了
4. 下一次循环时，`think()` 又执行，但状态可能被重置

### 核心问题 3：消息重复添加导致膨胀

**问题现象**：
- 每次 `think()` 都会添加 `next_step_prompt` 作为用户消息
- 即使 `next_step_prompt` 内容相同，也会重复添加
- 导致消息列表不断增长，消耗大量 token

**根本原因**：
```python
# 优化前的 think() 方法
if self.next_step_prompt:
    user_msg = Message.user_message(self.next_step_prompt)
    self.messages += [user_msg]  # ❌ 问题：每次都添加，不检查是否已存在
```

**影响**：
- 简单问答场景：消息数从 6 条增长到 48 条（8 倍增长）
- Token 消耗：每次循环都包含所有历史消息
- 性能下降：消息越多，LLM 处理越慢

### 核心问题 4：前端 WebSocket 端口配置错误

**问题现象**：
- 前端尝试连接 `ws://localhost:8000/ws`
- 但后端实际运行在 `8080` 端口
- 导致 WebSocket 连接失败，前端显示连接错误

**根本原因**：
- 前端代码中硬编码了 `ws://localhost:8000/ws`
- 虽然 `vite.config.js` 配置了代理，但前端代码绕过了代理直接连接

---

## 🎯 解决方案

### 解决思路

针对发现的 4 个核心问题，我们采用了以下解决策略：

1. **自动终止机制**：在 `think()` 中检测纯文本回答，自动设置 `FINISHED` 状态
2. **流处理状态检查**：在 `step()` 后立即检查状态，如果 `FINISHED` 则立即退出循环
3. **消息去重机制**：检查最近的用户消息，避免重复添加相同的提示词
4. **端口配置修复**：统一前端 WebSocket 连接端口为 8080

### 核心设计原则

1. **自动终止**：当 LLM 返回纯文本回答（无 tool_calls）时，自动终止
2. **避免重复**：跟踪已处理的用户输入，避免重复添加提示词
3. **灵活扩展**：子类可以通过重写 `should_auto_terminate()` 自定义终止逻辑
4. **状态同步**：确保 Agent 状态和流处理循环状态同步

### 架构设计

```
ToolCallAgent (基类)
├── should_auto_terminate()      # 可重写的终止判断逻辑
├── _should_add_next_step_prompt() # 避免重复消息
└── think()                       # 自动终止集成

Manus (子类)
├── should_auto_terminate()       # 自定义终止逻辑（过滤系统短语）
└── think()                      # 简化意图处理
```

---

## 🔧 详细解决方案

### 问题 1 解决方案：自动终止机制

**问题回顾**：LLM 返回纯文本回答时，Agent 不会自动终止，导致无限循环。

**解决步骤**：

#### 步骤 1：创建可重写的终止判断方法

在 `ToolCallAgent` 基类中添加 `should_auto_terminate()` 方法，允许子类自定义终止逻辑：

```python
def should_auto_terminate(self, content: str, tool_calls: List[ToolCall]) -> bool:
    """判断是否应该自动终止

    子类可以重写此方法来自定义终止逻辑。
    默认行为：当 LLM 返回纯文本内容（无 tool_calls）时自动终止。
    """
    # 如果有工具调用，不自动终止
    if tool_calls:
        return False

    # 如果有内容但没有工具调用，自动终止（纯文本回答）
    if content and content.strip():
        return True

    return False
```

#### 步骤 2：在 `think()` 中集成自动终止逻辑

修改 `think()` 方法，当检测到应该终止时，设置状态并返回 `False`：

```python
# 🔑 关键优化：自动终止逻辑
if self.tool_choices == ToolChoice.AUTO and not self.tool_calls:
    if self.should_auto_terminate(content, tool_calls):
        logger.info(f"✅ 自动终止：LLM 返回纯文本回答，无需继续")
        self.state = AgentState.FINISHED  # ✅ 设置终止状态
        return False  # ✅ 返回 False 停止执行
    return bool(content)
```

**解决效果**：
- ✅ 当 LLM 返回纯文本回答时，立即设置 `FINISHED` 状态
- ✅ `think()` 返回 `False`，停止继续执行
- ✅ 避免无限循环

### 问题 2 解决方案：流处理中的状态检查

**问题回顾**：即使 `think()` 设置了 `FINISHED` 状态，流处理循环没有立即检测到，继续执行。

**解决步骤**：

#### 步骤 1：在 `step()` 后立即检查状态

在 `agent_stream.py` 的循环中，执行 `step()` 后立即检查 Agent 状态：

```python
# 执行一步
step_result = await self.agent.step()

# 🔍 调试：检查状态变化
if self.agent.state == SchemaAgentState.FINISHED:
    logger.info(f"✅ Agent 状态已设置为 FINISHED，准备退出循环")
    # 🔑 关键修复：如果状态是 FINISHED，立即退出循环
    # 先发送最终答案（如果有）
    final_answer = None
    for msg in reversed(self.agent.memory.messages):
        if msg.role == "assistant" and msg.content:
            final_answer = msg.content
            break

    if final_answer and not self._answer_sent_in_loop:
        yield AnswerEvent(
            content=final_answer,
            is_complete=True,
            session_id=self._session_id,
        )
        self._answer_sent_in_loop = True

    # 退出循环
    break  # ✅ 立即退出，不再继续执行
```

**解决效果**：
- ✅ `step()` 后立即检查状态
- ✅ 如果状态为 `FINISHED`，立即退出循环
- ✅ 确保最终答案被发送给前端
- ✅ 避免继续执行不必要的步骤

### 问题 3 解决方案：消息去重机制

**问题回顾**：每次 `think()` 都添加 `next_step_prompt`，导致消息列表不断增长。

**解决步骤**：

#### 步骤 1：创建消息去重检查方法

添加 `_should_add_next_step_prompt()` 方法，检查最近的用户消息：

```python
def _should_add_next_step_prompt(self) -> bool:
    """判断是否应该添加 next_step_prompt

    避免重复添加相同的提示词，导致消息膨胀。
    """
    if not self.next_step_prompt:
        return False

    # 检查最后一条用户消息是否已经是这个 prompt
    for msg in reversed(self.messages[-3:]):
        if isinstance(msg, Message):
            role = msg.role.value if hasattr(msg.role, 'value') else str(msg.role)
        else:
            role = msg.get('role', '')

        if role == 'user':
            content = msg.content if isinstance(msg, Message) else msg.get('content', '')
            # 如果最近的用户消息就是 next_step_prompt，跳过添加
            if content and content.strip() == self.next_step_prompt.strip():
                return False  # ✅ 已存在，跳过添加
            break

    return True  # ✅ 不存在，可以添加
```

#### 步骤 2：在 `think()` 中使用去重检查

```python
# 🔑 关键优化：只在需要时添加 next_step_prompt
if self._should_add_next_step_prompt():
    user_msg = Message.user_message(self.next_step_prompt)
    self.messages += [user_msg]
    logger.debug(f"📝 添加 next_step_prompt: {self.next_step_prompt[:50]}...")
else:
    logger.debug("⏭️ 跳过重复的 next_step_prompt")
```

**解决效果**：
- ✅ 避免重复添加相同的提示词
- ✅ 减少消息数量（从 48 条降至 8 条）
- ✅ 降低 token 消耗
- ✅ 提升响应速度

### 问题 4 解决方案：端口配置修复

**问题回顾**：前端硬编码连接 8000 端口，但后端运行在 8080 端口。

**解决步骤**：

#### 步骤 1：修复前端 WebSocket 连接

修改 `frontend/src/App.jsx`：

```javascript
// 修复前
const wsUrl = 'ws://localhost:8000/ws';  // ❌ 错误端口

// 修复后
const wsUrl = 'ws://localhost:8080/ws';  // ✅ 正确端口
```

#### 步骤 2：更新错误提示信息

```javascript
// 修复前
content: '⚠️ 无法连接到服务器，请检查后端服务是否运行（端口 8000）。正在尝试重连...'

// 修复后
content: '⚠️ 无法连接到服务器，请检查后端服务是否运行（端口 8080）。正在尝试重连...'
```

**解决效果**：
- ✅ 前端正确连接到后端 8080 端口
- ✅ WebSocket 连接正常
- ✅ 消息可以正常传递

---

## 🔧 核心改进点

### 1. 自动终止机制 (`ToolCallAgent.should_auto_terminate`)

**位置**: `app/agent/toolcall.py`

**功能**: 判断是否应该自动终止执行

```python
def should_auto_terminate(self, content: str, tool_calls: List[ToolCall]) -> bool:
    """判断是否应该自动终止

    子类可以重写此方法来自定义终止逻辑。
    默认行为：当 LLM 返回纯文本内容（无 tool_calls）时自动终止。
    """
    # 如果有工具调用，不自动终止
    if tool_calls:
        return False

    # 如果有内容但没有工具调用，自动终止（纯文本回答）
    if content and content.strip():
        return True

    return False
```

**集成到 `think()` 方法**:

```python
# 🔑 关键优化：自动终止逻辑
if self.tool_choices == ToolChoice.AUTO and not self.tool_calls:
    if self.should_auto_terminate(content, tool_calls):
        logger.info(f"✅ 自动终止：LLM 返回纯文本回答，无需继续")
        self.state = AgentState.FINISHED
        return False
    return bool(content)
```

### 2. 避免重复消息 (`ToolCallAgent._should_add_next_step_prompt`)

**位置**: `app/agent/toolcall.py`

**功能**: 检查最近的用户消息，避免重复添加相同的提示词

```python
def _should_add_next_step_prompt(self) -> bool:
    """判断是否应该添加 next_step_prompt

    避免重复添加相同的提示词，导致消息膨胀。
    """
    if not self.next_step_prompt:
        return False

    # 检查最后一条用户消息是否已经是这个 prompt
    for msg in reversed(self.messages[-3:]):
        if role == 'user':
            content = msg.content if isinstance(msg, Message) else msg.get('content', '')
            # 如果最近的用户消息就是 next_step_prompt，跳过添加
            if content and content.strip() == self.next_step_prompt.strip():
                return False
            break

    return True
```

**集成到 `think()` 方法**:

```python
# 🔑 关键优化：只在需要时添加 next_step_prompt
if self._should_add_next_step_prompt():
    user_msg = Message.user_message(self.next_step_prompt)
    self.messages += [user_msg]
    logger.debug(f"📝 添加 next_step_prompt: {self.next_step_prompt[:50]}...")
else:
    logger.debug("⏭️ 跳过重复的 next_step_prompt")
```

### 3. 简化意图处理 (`Manus.think`)

**位置**: `app/agent/manus.py`

**改进**:
- **GREETING/LOAD_RESUME**：直接处理，不进入 LLM 循环
- **UNKNOWN**：返回空的 `next_step_prompt`，让 LLM 自然回答
- **自动终止**：LLM 回答后自动设置 `AgentState.FINISHED`

```python
async def _generate_next_step_prompt(self, intent: "Intent" = None) -> str:
    """生成下一步提示词

    对话类意图（GREETING、UNKNOWN）：返回空字符串，避免重复消息
    """
    # 🔑 对话类意图：返回空字符串，避免重复消息
    if intent in [Intent.GREETING, Intent.UNKNOWN]:
        return ""

    # ... 其他逻辑
```

### 4. 自定义终止逻辑 (`Manus.should_auto_terminate`)

**位置**: `app/agent/manus.py`

**功能**: 过滤系统短语，避免误终止

```python
def should_auto_terminate(self, content: str, tool_calls: list) -> bool:
    """自定义自动终止逻辑

    Manus 的终止策略：
    1. 如果有工具调用，不终止
    2. 如果 LLM 返回了有意义的内容（问答场景），自动终止
    3. 如果内容是系统指令的重复，不终止（可能是错误状态）
    """
    if tool_calls:
        return False

    if not content or not content.strip():
        return False

    # 检查是否是有意义的回答（不是系统指令的重复）
    system_phrases = [
        "好的，我明白了",
        "我会直接回答",
        "如果需要使用工具",
    ]

    # 如果回答太短且包含系统短语，可能是错误状态
    for phrase in system_phrases:
        if phrase in content and len(content) < 100:
            logger.debug(f"⚠️ 检测到可能的系统短语重复，跳过自动终止")
            return False

    # 有实质性内容，自动终止
    return True
```

---

## 📊 测试结果

### 优化后测试数据

| 场景 | 步数 | 消息数 | 状态 |
|------|------|--------|------|
| 加载简历 | 2 | 4 | ✅ |
| 询问个人信息 | 1 | 6 | ✅ |
| 通用知识问答 | 1 | 8 | ✅ |
| 技能询问 | 2 | 12 | ✅ |
| 问候 | 1 | 14 | ✅ |

**总步数**: 7步（5个场景）
**最终消息数**: 14条

### 性能对比

| 指标 | 优化前 | 优化后 | 改进 |
|------|--------|--------|------|
| 3个场景总步数 | 22步 | 4步 | **↓ 82%** |
| 3个场景消息数 | 48条 | 8条 | **↓ 83%** |
| 循环问题 | ❌ 有 | ✅ 无 | **已解决** |

---

## 🔄 代码变更总结

### 修改的文件

1. **`app/agent/toolcall.py`**
   - 新增 `should_auto_terminate()` 方法（可重写）
   - 新增 `_should_add_next_step_prompt()` 方法
   - 修改 `think()` 方法，集成自动终止逻辑
   - 新增 `_last_processed_user_input` 和 `_pending_next_step` 状态跟踪

2. **`app/agent/manus.py`**
   - 重写 `should_auto_terminate()` 方法（自定义终止逻辑）
   - 简化 `_generate_next_step_prompt()` 方法（对话类意图返回空字符串）
   - 简化 `think()` 方法（移除复杂的终止逻辑，依赖自动终止）

### 新增的扩展点

- **`should_auto_terminate()`**: 子类可以重写此方法来自定义终止逻辑
- **`_should_add_next_step_prompt()`**: 子类可以重写此方法来自定义提示词添加逻辑

---

## 🎨 设计优势

### 1. 扩展性

- **基类提供默认行为**：`ToolCallAgent` 提供基础的自动终止逻辑
- **子类可自定义**：`Manus` 可以通过重写方法自定义行为
- **不破坏现有功能**：向后兼容，不影响现有代码

### 2. 灵活性

- **场景无关**：不局限于特定场景，适用于所有对话场景
- **可配置**：通过重写方法可以调整终止策略
- **可扩展**：未来可以添加更多终止条件

### 3. 性能

- **减少循环**：自动终止避免无限循环
- **减少消息**：避免重复消息，降低 token 消耗
- **提升响应速度**：简单问答场景从 10+ 步降至 1 步

---

## 📝 使用指南

### 对于开发者

1. **继承 `ToolCallAgent`**:
   ```python
   class MyAgent(ToolCallAgent):
       def should_auto_terminate(self, content: str, tool_calls: List[ToolCall]) -> bool:
           # 自定义终止逻辑
           return super().should_auto_terminate(content, tool_calls)
   ```

2. **自定义终止条件**:
   - 检查内容长度
   - 检查特定关键词
   - 检查对话状态
   - 检查工具调用结果

3. **避免重复消息**:
   - 重写 `_should_add_next_step_prompt()` 来自定义提示词添加逻辑

### 对于测试

- 使用 `test_agent_scenarios.py` 进行场景测试
- 使用 `test_comprehensive_flow.py` 进行综合测试
- 验证自动终止是否正常工作
- 验证消息数量是否合理

---

## 🔮 未来优化方向

1. **基于 Token 的终止**：当回答达到一定长度时自动终止
2. **基于时间的终止**：当执行时间超过阈值时自动终止
3. **智能终止判断**：使用 LLM 判断是否应该终止
4. **终止原因记录**：记录终止原因，便于调试和优化

---

## 🐛 调试过程

### 问题定位

1. **浏览器测试**：使用浏览器工具测试前端，发现 WebSocket 连接失败
2. **日志分析**：检查后端日志，发现 Agent 在执行但前端没有收到响应
3. **代码审查**：检查 `think()` 和 `agent_stream.py`，发现状态检查缺失
4. **测试验证**：创建测试脚本验证自动终止机制

### 关键调试日志

```python
# 添加的调试日志
logger.info(f"✅ 自动终止：LLM 返回纯文本回答，无需继续")
logger.info(f"✅ Agent 状态已设置为 FINISHED，准备退出循环")
logger.debug("⏭️ 跳过重复的 next_step_prompt")
```

### 测试验证

使用 `test_comprehensive_flow.py` 和 `test_agent_scenarios.py` 进行验证：
- ✅ 加载简历：2 步完成
- ✅ 问答场景：1 步完成（之前需要 10+ 步）
- ✅ 无循环问题
- ✅ 消息数量合理

---

## ✅ 总结

本次优化通过引入**自动终止机制**、**流处理状态检查**、**消息去重机制**和**端口配置修复**，成功解决了 Agent 的循环问题、消息膨胀问题和连接问题。

### 问题解决总结

| 问题 | 原因 | 解决方案 | 效果 |
|------|------|----------|------|
| 无限循环 | `think()` 返回 `True` 导致继续执行 | 自动终止机制 | ✅ 消除循环 |
| 流处理卡住 | 状态检查在循环开始，不在 `step()` 后 | 立即状态检查 | ✅ 正确终止 |
| 消息膨胀 | 重复添加 `next_step_prompt` | 消息去重机制 | ✅ 减少 83% |
| 连接失败 | 端口配置错误（8000 vs 8080） | 统一端口配置 | ✅ 连接正常 |

**核心成果**:
- ✅ 消除无限循环问题
- ✅ 减少 83% 的消息数量
- ✅ 减少 82% 的执行步数
- ✅ 修复 WebSocket 连接问题
- ✅ 提升代码扩展性和灵活性
- ✅ 保持向后兼容性

**性能提升**:
- 简单问答场景：从 10+ 步降至 1 步（**↓ 90%**）
- 消息数量：从 48 条降至 8 条（**↓ 83%**）
- Token 消耗：显著降低
- 响应速度：明显提升

