# 意图识别机制详细分析

**分析日期**: 2026-01-06
**代码版本**: 最新 dev 分支

## 📋 概述

当前系统采用**简化的意图识别 + LLM 工具路由**方案，在保持灵活性的同时优化性能。

**核心设计理念**:
- **最小化意图枚举**: 仅保留必须在代码层面特殊处理的意图（3个）
- **LLM 自主决策**: 其他场景由 LLM 根据工具描述和上下文判断
- **可扩展性**: 添加新工具无需修改意图类型
- **常识处理**: LLM 直接回答常识问题，不调用工具

---

## 🔍 意图识别流程

### 1. 意图分类阶段

**位置**: `app/memory/conversation_state.py` → `classify_intent_with_llm()`

**流程**:
```
用户输入
    │
    ▼
┌───────────────────────────────────────────────┐
│   LLM 意图分类 (仅识别特殊意图)              │
│   - greeting: 问候语                          │
│   - load_resume: 加载简历                     │
│   - unknown: 其他所有情况                     │
└───────────────────────────────────────────────┘
    │
    ▼
返回 JSON:
{
  "intent": "greeting/load_resume/unknown",
  "confidence": 0.0-1.0,
  "reasoning": "简短理由"
}
```

**提示词示例**:
```python
prompt = f"""你是一个意图识别助手。根据用户输入判断是否为特殊意图。

## 用户输入
"{user_input}"

## 意图类型
- greeting: 问候语（你好、hi、hello、嘿等）
- load_resume: 加载简历（包含"加载简历"、"导入简历"等，且后面通常跟着文件路径）
- unknown: 其他所有情况（交给 LLM 根据上下文处理）

## 输出格式（JSON）
{{
    "intent": "greeting/load_resume/unknown",
    "confidence": 0.0-1.0,
    "reasoning": "简短理由"
}}

只返回JSON。"""
```

**关键点**:
- 只识别 3 种特殊意图
- 其他所有情况都归为 `UNKNOWN`
- 使用 `temperature=0.1` 确保稳定性

---

### 2. 路由决策阶段

**位置**: `app/agent/manus.py` → `think()`

**决策树**:
```
意图识别结果
    │
    ├── GREETING
    │   └──→ 直接返回问候语
    │       └──→ 设置 AgentState.FINISHED
    │       └──→ 终止执行
    │
    ├── LOAD_RESUME
    │   └──→ 检查是否已加载
    │       ├── 已加载 → 跳过，返回成功消息
    │       └── 未加载 → 调用 cv_reader_agent
    │
    └── UNKNOWN
        └──→ 交给 LLM 根据以下判断:
            ├── 系统提示词 (工具列表和规则)
            ├── 工具描述 (description)
            ├── 对话上下文
            └── 是否常识问题
```

---

## 🎯 工具调用决策机制

### UNKNOWN 意图的处理

当意图为 `UNKNOWN` 时，系统将决策权交给 LLM，LLM 根据以下信息判断：

#### 1. 系统提示词 (`app/prompt/manus.py`)

```python
SYSTEM_PROMPT = """You are OpenManus, an AI assistant for resume optimization.

## Core Principles

1. **Resume-related tasks** → Use appropriate tools
2. **General questions** → Answer directly using your knowledge, NO tools
3. **Understand context** → Consider conversation history and resume state

## Available Tools

| Tool | When to Use |
|------|-------------|
| cv_reader_agent | Load resume from file path |
| cv_analyzer_agent | Analyze resume quality and content |
| education_analyzer | Analyze education background specifically |
| cv_editor_agent | Edit resume content |
| terminate | Complete the task |

## Guidelines

- **DO** use tools for resume operations (loading, analyzing, editing)
- **DO NOT** use browser/search tools for general knowledge questions
- **DO** answer common questions directly using your own knowledge
- **DO** call terminate when the task is complete
- Working language: Chinese
"""
```

**关键规则**:
- ✅ 简历相关任务 → 使用工具
- ✅ 常识性问题 → 直接回答，不用工具
- ✅ 理解上下文 → 考虑对话历史和简历状态

#### 2. 工具描述 (Tool Description)

每个工具都有详细的 `description`，这是 LLM 选择工具的关键依据：

**示例 1: cv_analyzer_agent**
```python
description = """Delegate CV/Resume deep analysis to the CVAnalyzer Agent.

Use this tool when the user asks to:
- "分析我的简历" (analyze my resume)
- "帮我分析一下简历" (help me analyze my resume)
- "找出简历需要优化的地方" (find areas that need improvement)
- "深度分析简历" (deeply analyze the resume)

The CVAnalyzer Agent will:
1. Check completeness (empty/missing fields)
2. Analyze content quality using STAR methodology
3. Identify skills that need better description
4. Provide structured optimization suggestions

此工具用于深度分析求职者的简历内容质量。"""
```

**示例 2: cv_editor_agent**
```python
description = """Edit and modify CV/Resume data through the CVEditor Agent.

Use this tool when user requests to modify resume content.

**Keywords:** 修改, 更新, 改成, 改为, 设置, 添加, 增加, 删除, 去掉

**Parameters:**
- path: JSON path to the field (e.g., 'basic.name', 'education[0].school', 'education')
- action: 'update', 'add', or 'delete'
- value: New value (for update/add operations)

Execute modifications immediately when user provides specific details.
"""
```

**示例 3: education_analyzer**
```python
description = """Analyze education background specifically.
Use this when user asks about education, degrees, schools, or academic qualifications."""
```

**工具描述的关键要素**:
1. **明确用途**: 清楚说明工具做什么
2. **使用场景**: 说明何时使用这个工具
3. **关键词**: 包含用户可能使用的关键词
4. **参数说明**: 说明如何传递参数

#### 3. LLM 决策过程

当 LLM 收到用户输入和工具列表时，它会：

1. **理解用户意图**: 分析用户想要什么
2. **匹配工具描述**: 查找最匹配的工具
3. **判断是否需要工具**:
   - 简历相关 → 使用工具
   - 常识问题 → 直接回答
4. **生成工具调用**: 如果选择工具，生成 `tool_calls`
5. **生成文本回答**: 如果不需要工具，直接生成文本

---

## 📊 决策示例

### 示例 1: 简历分析任务

**用户输入**: "分析我的简历"

**流程**:
1. 意图识别 → `UNKNOWN` (不是 greeting 或 load_resume)
2. 交给 LLM 判断
3. LLM 看到系统提示词: "简历相关任务 → 使用工具"
4. LLM 匹配工具描述: `cv_analyzer_agent` 的描述包含 "分析我的简历"
5. LLM 生成工具调用: `cv_analyzer_agent({"question": "分析我的简历"})`
6. 执行工具 → 返回分析结果

### 示例 2: 常识问题

**用户输入**: "什么是985"

**流程**:
1. 意图识别 → `UNKNOWN`
2. 交给 LLM 判断
3. LLM 看到系统提示词: "常识性问题 → 直接回答，不用工具"
4. LLM 判断这是常识问题，不需要工具
5. LLM 直接生成文本回答: "985工程是指..."
6. **自动终止**: 因为返回纯文本（无 tool_calls），触发 `should_auto_terminate()`
7. 设置 `AgentState.FINISHED` → 终止执行

### 示例 3: 简历编辑任务

**用户输入**: "把学校改成北京大学"

**流程**:
1. 意图识别 → `UNKNOWN`
2. 交给 LLM 判断
3. LLM 看到系统提示词: "简历相关任务 → 使用工具"
4. LLM 匹配工具描述: `cv_editor_agent` 的描述包含 "修改"、"改成" 等关键词
5. LLM 生成工具调用: `cv_editor_agent({"path": "education[0].school", "action": "update", "value": "北京大学"})`
6. 执行工具 → 更新简历数据

### 示例 4: 查询已加载的简历信息

**用户输入**: "我是哪个学校的"

**流程**:
1. 意图识别 → `UNKNOWN`
2. 交给 LLM 判断
3. LLM 看到系统提示词: "理解上下文 → 考虑对话历史和简历状态"
4. LLM 检查上下文: 简历已加载，可以从已加载的简历数据中读取
5. LLM 判断: 这是查询已加载的数据，不需要调用工具
6. LLM 直接生成文本回答: "根据您的简历，您是中山大学的"
7. **自动终止**: 返回纯文本，触发自动终止

---

## 🔧 代码实现细节

### 1. 意图识别 (`app/memory/conversation_state.py`)

```python
class Intent(str, Enum):
    """用户意图 - 仅保留需要在代码层面特殊处理的意图"""
    GREETING = "greeting"      # 问候 - 直接返回，不走 LLM
    LOAD_RESUME = "load_resume"  # 加载简历 - 需检查重复
    UNKNOWN = "unknown"       # 其他 - 交由 LLM 判断

async def classify_intent_with_llm(
    self,
    user_input: str,
    conversation_history: List[Any] = None,
    last_ai_message: Optional[str] = None
) -> Dict[str, Any]:
    """使用 LLM 进行意图分类"""
    # 构建意图识别提示词
    prompt = f"""你是一个意图识别助手。根据用户输入判断是否为特殊意图。

    ## 用户输入
    "{user_input}"

    ## 意图类型
    - greeting: 问候语（你好、hi、hello、嘿等）
    - load_resume: 加载简历（包含"加载简历"、"导入简历"等）
    - unknown: 其他所有情况（交给 LLM 根据上下文处理）

    ## 输出格式（JSON）
    {{
        "intent": "greeting/load_resume/unknown",
        "confidence": 0.0-1.0,
        "reasoning": "简短理由"
    }}

    只返回JSON。"""

    # 调用 LLM
    response = await self.llm.ask(
        messages=[{"role": "user", "content": prompt}],
        stream=False,
        temperature=0.1  # 低温度确保稳定性
    )

    # 解析 JSON 返回
    result = json.loads(response)
    intent = Intent(result.get("intent", "unknown"))

    return {
        "intent": intent,
        "confidence": result.get("confidence", 0.5),
        "extracted_info": result.get("extracted_info", {}),
        "reasoning": result.get("reasoning", "")
    }
```

### 2. 路由决策 (`app/agent/manus.py`)

```python
async def think(self) -> bool:
    """处理用户输入并决定下一步行动"""

    # 1. 获取用户输入
    user_input = self._get_last_user_input()

    # 2. 意图识别
    intent_result = await self._conversation_state.process_input(
        user_input=user_input,
        conversation_history=self.memory.messages[-5:],
        last_ai_message=self._get_last_ai_message()
    )

    intent = intent_result["intent"]
    tool = intent_result.get("tool")
    tool_args = intent_result.get("tool_args", {})

    # 3. 路由决策
    if intent == Intent.GREETING:
        # 直接返回问候
        self.memory.add_message(Message.assistant_message(greeting_content))
        self.state = AgentState.FINISHED
        return False

    elif intent == Intent.LOAD_RESUME:
        # 检查是否已加载
        if self._conversation_state.context.resume_loaded:
            # 已加载，跳过
            self.memory.add_message(Message.assistant_message("简历已成功加载..."))
            self.state = AgentState.FINISHED
            return False
        else:
            # 未加载，直接调用工具
            return await self._handle_direct_tool_call(tool, tool_args, intent)

    else:  # UNKNOWN
        # 交给 LLM 判断
        self.system_prompt, self.next_step_prompt = await self._generate_dynamic_prompts(user_input, intent)
        return await super().think()  # 调用父类的 think()，LLM 会自主决策
```

### 3. LLM 工具路由 (`app/agent/toolcall.py`)

```python
async def think(self) -> bool:
    """LLM 自主决策是否调用工具"""

    # 调用 LLM，传入系统提示词和工具列表
    response = await self.llm.ask_tool(
        messages=self.messages,
        system_msgs=[Message.system_message(self.system_prompt)],
        tools=self.available_tools.to_params(),  # 包含所有工具的 description
        tool_choice=self.tool_choices,
    )

    self.tool_calls = response.tool_calls if response.tool_calls else []
    content = response.content if response.content else ""

    # 自动终止逻辑
    if self.tool_choices == ToolChoice.AUTO and not self.tool_calls:
        if self.should_auto_terminate(content, tool_calls):
            logger.info(f"✅ 自动终止：LLM 返回纯文本回答，无需继续")
            self.state = AgentState.FINISHED
            return False

    return bool(self.tool_calls)  # 有工具调用则继续执行
```

---

## 🎨 设计优势

### 1. 简洁性
- 仅 3 个意图类型，易于理解和维护
- 不需要复杂的意图分类逻辑

### 2. 灵活性
- LLM 可以根据上下文自主决策
- 工具描述可以灵活调整，无需修改代码

### 3. 可扩展性
- 添加新工具只需：
  1. 创建工具类
  2. 编写清晰的 `description`
  3. 添加到 `available_tools`
- **无需修改意图枚举**

### 4. 性能优化
- 特殊场景（GREETING、LOAD_RESUME）代码层处理，避免不必要的 LLM 调用
- 自动终止机制避免无限循环

### 5. 常识处理
- 显式提示 LLM 直接回答常识问题
- 避免不必要的工具调用

---

## 🔄 与 LangChain 的对比

| 特性 | LangChain 纯方案 | 当前设计 |
|------|-----------------|----------|
| **意图识别** | 无 | 仅特殊意图 (GREETING, LOAD_RESUME) |
| **工具选择** | 完全由 LLM 决定 | LLM 决定 + 代码层优化 |
| **性能** | 标准 | LOAD_RESUME 跳过重复检查 |
| **扩展性** | 高 | 高（添加工具无需修改意图） |
| **常识处理** | 依赖 LLM | 显式提示 LLM 直接回答 |
| **控制性** | 低 | 中等（特殊场景代码层控制） |

---

## 📝 总结

当前意图识别机制的核心特点：

1. **最小化意图枚举**: 只保留 3 个特殊意图
2. **LLM 自主决策**: UNKNOWN 意图交给 LLM 根据工具描述判断
3. **工具描述驱动**: 工具描述是 LLM 决策的关键依据
4. **自动终止机制**: 纯文本回答自动终止，避免无限循环
5. **可扩展性强**: 添加新工具无需修改意图类型

**决策流程总结**:
```
用户输入
    ↓
意图识别 (仅识别特殊意图)
    ↓
GREETING → 直接返回
LOAD_RESUME → 检查重复 → 调用工具
UNKNOWN → LLM 根据系统提示词 + 工具描述判断
    ↓
调用工具 OR 直接回答
    ↓
自动终止 (如果是纯文本回答)
```

这种设计在保持控制性的同时，最大程度地发挥了 LLM 的理解能力。

